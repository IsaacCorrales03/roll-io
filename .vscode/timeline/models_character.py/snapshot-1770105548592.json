{
  "timestamp": 1770105548592,
  "name": "antes de sourcery",
  "filename": "models/character.py",
  "hash": "632c57297a3979ab7fc1fba3961f55c79bd59e8503166e3ce54efa6facb962c9",
  "comment": "Implementación antes del clean code",
  "snapshot_filePath": "/home/cherry/Documentos/dnd/models/character.py",
  "content": "from .base import Actor, ClassFeature\nfrom .race import Race, ATTRIBUTE_KEYS\nfrom .weapon import Weapon\nfrom .dndclass import DnDClass\nimport random\nfrom typing import Optional\nimport uuid\n\nclass Character(Actor):\n    MAX_LEVEL = 20  # Nivel máximo permitido\n\n    def __init__(self, id: uuid.UUID, name: str, race: Race, dnd_class: DnDClass):\n        # Atributos base heredados de la raza\n        self.attributes = race.attributes.copy()\n        super().__init__(id, name, self.attributes)\n\n        # Identidad básica\n        self.name = name\n        self.level = 1\n\n        # Referencias a raza y clase\n        self.dnd_class = dnd_class\n        self.race = race\n\n        # Puntos para mejoras de atributos\n        self.points = 0\n\n        # Rasgos especiales raciales\n        self.special_triats = race.special_traits.copy()\n\n        # Competencias con armas según la clase\n        self.weapon_proficiencies = dnd_class.weapon_proficiencies.copy()\n\n        # Puntos de vida iniciales\n        self.max_hp = self.dnd_class.hit_die + self.con_mod\n        self.hp = self.max_hp\n\n        # Bono de competencia inicial\n        self.proficiency_bonus = 2\n\n        # Lista de habilidades de clase activas\n        self.features: list[ClassFeature] = []\n        self.apply_level_features()\n\n    def can_levelUp(self):\n        # Verifica si aún puede subir de nivel\n        return self.level < self.MAX_LEVEL\n\n    def levelUp(self, use_average=True):\n        if not self.can_levelUp():\n            return False\n\n        self.level += 1\n\n        # Aumento de vida por nivel\n        hp_gained = self.roll_hit_die(\n            self.dnd_class.hit_die,\n            self.con_mod,\n            use_average=use_average\n        )\n        self.max_hp += hp_gained\n        self.hp += hp_gained  # curación automática al subir de nivel\n\n        # ASI\n        if self.level in (4, 8, 12, 16, 19):\n            self.points += 2\n\n        self.apply_level_features()\n        return True\n\n\n    def assign_point(self, attribute: str, value: int = 1):\n        # Asigna puntos a atributos válidos\n        if self.points < value:\n            return False\n        if attribute not in ATTRIBUTE_KEYS:\n            return False\n\n        self.attributes[attribute] += value\n        self.points -= value\n        return True\n\n    def attack(self, target: Actor, advantage=False, disadvantage=False):\n        # Ataque básico con arma equipada\n        if not self.weapon:\n            return {}\n\n        # Tirada de ataque\n        tirada_ataque_total, tirada_dado, modificador, is_critical, is_fumble = (\n            self.roll(self.weapon.attribute, advantage, disadvantage)\n        )\n\n        bonus_tirada = 0\n\n        # Uso opcional de inspiración\n        if self.inspiration_dice:\n            fuente, info = next(iter(self.inspiration_dice.items()))\n            usar = input(\n                f\"{self.name}, ¿usar dado de Bardic Inspiration ({tirada_ataque_total})? (s/n)\"\n            ).lower() == \"s\"\n            if usar:\n                bonus_tirada += random.randint(1, info[\"die\"])\n                del self.inspiration_dice[fuente]\n                tirada_ataque_total += bonus_tirada\n\n        # Comprobación de impacto\n        if tirada_ataque_total >= target.calc_ac() and not is_fumble:\n            damage = self.damage_roll(self.weapon, is_critical)\n\n            # Bonificadores de habilidades activas\n            for feature in self.features:\n                if getattr(feature, \"active\", False):\n                    damage += getattr(feature, \"get_damage_bonus\", lambda: 0)()\n\n            target.hp -= damage\n\n            return {\n                \"hit\": True,\n                \"tirada_ataque_total\": tirada_ataque_total,\n                \"tirada_dado\": tirada_dado,\n                \"modificador\": modificador,\n                \"damage\": damage,\n                \"bonus_tirada\": bonus_tirada,\n                \"critical\": is_critical,\n                \"fumble\": False,\n                \"weapon\": self.weapon.name,\n                \"damage_type\": self.weapon.damage_type,\n            }\n\n        # Fallo del ataque\n        return {\n            \"hit\": False,\n            \"tirada_ataque_total\": tirada_ataque_total,\n            \"tirada_dado\": tirada_dado,\n            \"modificador\": modificador,\n            \"damage\": 0,\n            \"critical\": is_critical,\n            \"fumble\": False,\n            \"weapon\": self.weapon.name,\n            \"damage_type\": self.weapon.damage_type,\n        }\n\n    def roll_hit_die(self, hit_die: int, con_mod: int, use_average=False):\n        # Tirada de dado de golpe al subir de nivel\n        if use_average:\n            base = (hit_die // 2) + 1\n        else:\n            base = random.randint(1, hit_die)\n\n        return max(1, base + con_mod)\n\n    def can_act(self) -> bool:\n        # Control simple de energía por acción\n        if self.attributes[\"energy\"] >= 3:\n            self.attributes[\"energy\"] -= 3\n            return True\n        return False\n\n    def apply_level_features(self):\n        # Aplica las habilidades correspondientes al nivel actual\n        feature_classes = self.dnd_class.features_by_level().get(self.level, [])\n        for feature_cls in feature_classes:\n            feature = feature_cls()\n            feature.apply(self)\n\n    def to_json(self) -> dict:\n        # Serialización del personaje para API / frontend\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"level\": self.level,\n            \"race\": {\n                \"name\": self.race.name,\n                \"key\": self.race.key,\n                \"description\": self.race.description,\n                \"special_traits\": self.race.special_traits,\n                \"racial_bonus_stats\": self.race.racial_bonus_stats,\n            },\n            \"class\": {\n                \"name\": self.dnd_class.name,\n                \"hit_die\": self.dnd_class.hit_die,\n                \"weapon_proficiencies\": self.weapon_proficiencies,\n            },\n            \"attributes\": self.attributes,\n            \"points\": self.points,\n            \"hp\": {\n                \"current\": self.hp,\n                \"max\": self.max_hp,\n            },\n            \"proficiency_bonus\": self.proficiency_bonus,\n            \"features\": [\n                {\n                    \"name\": f.name,\n                    \"description\": f.description,\n                    \"level_required\": f.level,\n                }\n                for f in self.features\n            ],\n        }\n\n\ndef create_character_Class(id: uuid.UUID, nombre: str, raza: Race, dnd_class: DnDClass):\n    # Factory simple para creación de personajes\n    return Character(id, nombre, raza, dnd_class)\n"
}